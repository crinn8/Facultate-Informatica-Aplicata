(coperta)
1 click

(cuprins)
1 click

(intro)
Metoda Greedy este o tehnicÄƒ folositÄƒ Ã®n informaticÄƒ, Ã®n general, Ã®n rezolvarea problemelor de optimizare, pentru a determina cel mai bun candidat dintr-o anumitÄƒ categorie. 

(structura algo)
Un algoritm greedy se carcterizeazÄƒ prin faptul cÄƒ Ã®mparte problema Ã®n subprobleme independente pentru care calculeazÄƒ un optim local Ã®n speranÈ›a gÄƒsirii unui optim global.

(avantaje)
Implementarea simplÄƒ È™i intuitivÄƒ, soluÈ›ia optimÄƒ la nivel local È™i complexitatea polinomialÄƒ reprezintÄƒ principalele avantaje ale acestei metode. Dintre algoritmii greedy cunoscuÈ›i menÈ›ionÄƒm: Dijkstra, Prim, Kruskal. 

(dezavantaje)
Pe lÃ¢ngÄƒ multiplele avantaje, aceastÄƒ tehnicÄƒ are È™i dezavantaje, neoferind siguranÈ›a obÈ›inerii unei soluÈ›ii sau a optimului global. Mai mult, cÃ¢nd vine vorba despre corectitudine, demonstrarea acesteia poate fi dificilÄƒ.

(structura probleme)
Pentru a recunoaÈ™te mai uÈ™or o problemÄƒ a cÄƒrei rezolvare utilizeazÄƒ metoda greedy, identificÄƒm o serie de trÄƒsÄƒturi specifice: se dÄƒ o mulÈ›ime de candidaÈ›i A, È™i se cere o submulÈ›ime a sa care trebuie sÄƒ Ã®ndeplineascÄƒ anumite condiÈ›ii interne È™i sÄƒ fie oprimalÄƒ, adicÄƒ sÄƒ realizele un maxim sau un minim.

(probleme rezolvate)
Pentru o mai bunÄƒ Ã®nÈ›elegere a metodei prezentate, am pregÄƒtit 2 probleme. Ãn prima problemÄƒ, Facultatea de Biologie amplaseazÄƒ un acvariu È™i le propune studenÈ›ilor sÄƒ  afle dacÄƒ Ã®n acesta existÄƒ un piranha dominant.

(explicatie)
Un peÈ™te este numit dominant dacÄƒ acesta poate mÃ¢nca toÈ›i ceilalÈ›i peÈ™ti din acvariu. Deoarece acvariul este destul de Ã®ngust È™i lung, un peÈ™te poate mÃ¢nca doar peÈ™tii adiacenÈ›i acestuia Ã®ntr-o miÈ™care, dimensiunea lui crescÃ¢nd. Ãn acest caz o soluÈ›ie optimÄƒ ar fi peÈ™tele de pe poziÈ›ia a 3-a.  


!VEZI IMPLEMENTAREA+
Aceasta este implementarea problemei.

ConsiderÄƒm a vectorul Ã®n care reÈ›inem mÄƒrimile peÈ™tilor. VerificÄƒm dacÄƒ mÄƒrimile tuturor peÈ™tilor sunt diferite, iar Ã®n caz contrar, nu existÄƒ niciun peÈ™te dominant, deci algoritmul returneazÄƒ valoarea -1. Pentru rezolvarea problemei vom cÄƒuta mÄƒrimea maximÄƒ a unui peÈ™te. DupÄƒ, parcurgÃ¢nd vectorul de mÄƒrimi din nou, cÄƒutÄƒm un peÈ™te de mÄƒrime maximÄƒ, iar dacÄƒ acesta poate mÃ¢nca mÄƒcar un peÈ™te, Ã®l vom considera piranha dominant. Corectitudinea problemei constÄƒ Ã®n faptul cÄƒ oricare peÈ™te de mÄƒrime maximÄƒ care poate mÃ¢nca minim un alt peÈ™te va fi mai mare decÃ¢t restul, deci acesta este soluÈ›ia.

Ãn cazul favorabil, peÈ™tele se aflÄƒ pe prima sau pe ultima poziÈ›ie, iar complexitatea este O(n). DeÈ™i Ã®n celelalte cazuri se parcurge È™irul Ã®ncÄƒ o datÄƒ, complexitatea este tot O(n). 

A doua problmÄƒ prezintÄƒ rugÄƒmintea unui prieten de a Ã®l ajuta sÄƒ ardÄƒ scrisorile de dragoste de la fosta lui iubitÄƒ. El doreÈ™te sÄƒ ardÄƒ cÃ¢t mai multe scrisori, fiecare dintre acestea avÃ¢nd o anumitÄƒ duratÄƒ de ardere. TotuÈ™i el e condiÈ›ionat de timp. AjutÄƒ-l sÄƒ afle cÃ¢te poate arde Ã®n timpul dat.

!VEZI IMPLEMENTAREA
treci peste

Problema prezentatÄƒ anterior este una de optimizare, care presupune determinarea unui numÄƒr maxim de scrisori care pot fi arse Ã®ntr-un 
anumit timp. Pentru acest lucru se sorteazÄƒ crescÄƒtor vectorul care conÈ›ine pentru fiecare scrisoare timpul sÄƒu de ardere, iar apoi se 
alege candidatul cu timpul de ardere minim, Ã®n cazul Ã®n care acest timp este mai mic decÃ¢t timpul rÄƒmas pentru ardeerea scrisorilor. Ãn 
cazul Ã®n care este un candidat bun Ã®l adaugÄƒm Ã®n soluÈ›ie, Ã®n caz contrar Ã®nseamnÄƒ cÄƒ timpul total de ardere a devenit mai mic decÃ¢t timpul 
oricÄƒrei scrisori din vector È™i ne oprim. Pentru a demonstra corectitudinea acestei implementÄƒri presupunem cÄƒ setul de scrisori este
 ordonat crescÄƒtor dupÄƒ timpul de ardere necesar pentru fiecare scrisoare.
   Alegem o soluÈ›ie optimÄƒ cu un numÄƒr de m elemente È™i o comparÄƒm cu soluÈ›ia oferitÄƒ de program.
DacÄƒ k > m atunci O nu este soluÈ›ia optimÄƒ. 
DacÄƒ k = m atunci X este optimÄƒ.
DacÄƒ k < m, atunci putem Ã®nlocui Ã®n O prima scrisoare cu prima scrisoare din soluÈ›ia noastrÄƒ (scrisoarea care arde cel mai repede) fÄƒrÄƒ a 
altera restricÈ›ia problemei È™i pÄƒstrÃ¢nd acelaÈ™i numÄƒr (maxim) de scrisori selectate. ObÈ›inem soluÈ›ia optimÄƒ Oâ€² = (ğ‘¥_1, ğ‘œ_2, . . . , ğ‘œ_(ğ‘š )). 
Proprietatea de substructurÄƒ optimÄƒ. ConsiderÄƒm soluÈ›ia optimÄƒ Oâ€²= (ğ‘¥_1 , . . . , ğ‘œ_(ğ‘š )).). Presupunem cÄƒ (ğ‘œ_2, . . . , ğ‘œ_(ğ‘š )) nu este 
soluÈ›ie optimÄƒ pentru subproblema selecÈ›iei subsetul considerat. RezultÄƒ cÄƒ existÄƒ Oâ€²â€² = (ğ‘œâ€²â€²_2, . . . , ğ‘œâ€²â€²_ğ‘˜â€²â€²) o alta soluÈ›ie 
cu kâ€²â€²  > m. Acest lucru ar conduce la o soluÈ›ie (ğ‘¥_1, ğ‘œâ€²â€²_2, . . . , ğ‘œâ€²â€²_ğ‘˜â€²â€²) mai bunÄƒ decÃ¢t Oâ€²= (ğ‘¥_1, ğ‘œ_2 , . . . , ğ‘œ_(ğ‘š )).). 
Ceea ce ne conduce la o contradicÈ›ie. 

Complexitatea acestei probleme este reprezentatÄƒ de maximul dintre complexitÄƒÈ›ile subprogramelor care o alcÄƒtuiesc. Astfel, metodele de 
citire È™i de rezlovare au complexitate polinomialÄƒ ( O(n)), principalÄƒ Ã®n acestea (din punctul de vedere al complexitÄƒÈ›ii) fiind structura
repetitivÄƒ "for", iar metoda de afiÈ™are are complexitate liniarÄƒ O(1), fiind alcÄƒtuitÄƒ doar din instrucÈ›iuni simple, fÄƒrÄƒ structuri 
repetitive.
 